<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="go, development, history, language design, ">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Go – On The Shoulders of Giants : spf13.com"/>
<meta property="og:site_name" content="spf13 is Steve Francia"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="http://localhost:888/presentation/on-the-shoulders-of-giants/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-07-17"/>
<meta property="article:modified_time" content="2018-07-17"/>



<meta property="article:tag" content="go">
<meta property="article:tag" content="development">
<meta property="article:tag" content="history">
<meta property="article:tag" content="language design">




<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@spf13">
<meta name="twitter:title" content="Go – On The Shoulders of Giants : spf13.com">
<meta name="twitter:creator" content="@spf13">
<meta name="twitter:description" content="">
<meta name="twitter:image:src" content="">
<meta name="twitter:domain" content="spf13.com">



    <base href="http://localhost:888/">
    <title> Go – On The Shoulders of Giants - spf13.com </title>
    <link rel="canonical" href="http://localhost:888/presentation/on-the-shoulders-of-giants/">
    

    <link href='https://fonts.googleapis.com/css?family=Fjalla+One|Open+Sans:300' rel='stylesheet' type='text/css'>

<link rel="stylesheet" href="http://localhost:888/css/ZGS.min.8b403dad8c58a1830355fb210b5ead5e5472e11a4e5d7bfe5ee2931e6a2c54e8.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
</head>

<body lang="en" itemscope itemtype="http://schema.org/Article">
<header id="header">
    <figure>
      <a href="/" border=0 id="logolink"><div class="icon-spf13-3" id="logo"> </div></a>
    </figure>
    <nav id="nav">
            <ul id="mainnav">
            <li>
                <a href="/post/">
                <span class="icon"> <i aria-hidden="true" class="icon-quill"></i></span>
                <span> articles </span>
            </a>
            </li>
            <li>
            <a href="/project/">
                <span class="icon"> <i aria-hidden="true" class="icon-console"></i></span>
                <span> projects </span>
            </a>
            </li>
            <li>
            <a href="/presentation/">
                <span class="icon"> <i aria-hidden="true" class="icon-stats"></i></span>
                <span> presentations </span>
            </a>
            </li>
        </ul>

            <ul id="social">
            <li id="follow">
                <span class="title"> follow </span>
                <div class="dropdown follow">
                    <ul class="social">
                        <li> <a href="https://feeds.feedburner.com/spf13" target="_blank" title="Subscribe by RSS" class="rss"><span class="icon icon-feed-2"></span>RSS</a> </li>
                        <li> <a href="https://www.twitter.com/spf13" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                        <li> <a href="https://www.facebook.com/stevefrancia" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                        <li> <a href="https://www.linkedin.com/in/stevefrancia" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                        <li> <a href="https://github.com/spf13" target="_blank" title="GitHub" class="github"><span class="icon icon-github"></span>GitHub</a> </li>
                        <li> <a href="https://slideshare.com/spf13" target="_blank" title="SlideShare" class="slideshare"><span class="icon icon-slideshare"></span>SlideShare</a> </li>
                    </ul>
                    <span class="subcount">join 40k+ subscribers &amp; followers</span>
                </div>
            </li>
        </ul>

    </nav>
</header>



<section id="main">
  <h1 itemprop="name" id="title">Go – On The Shoulders of Giants</h1>
  <div>
        <article itemprop="articleBody" id="content">
           <p>This presentation was developed for <a href="http://www.curry-on.org/2018/">Curry On</a> and delivered as the closing keynote of the conference. The presentation describes the many inspirations and influences of the <a href="http://golang.org">Go programming language</a> and goes into detail about how we shaped and created the language.</p>
<h2 id="slides">Slides</h2>
<!-- raw HTML omitted -->
<h2 id="recording">Recording</h2>
<!-- raw HTML omitted -->
<h2 id="transcript">Transcript</h2>
<p>Building on the Shoulders of Giants
Curry On – Amsterdam – July 17 2018
Steve Francia
Google
@spf13</p>
<p>In the late 1950s people were becoming uneasy how each new computer spawned its own distinct language.
At the time, programming languages were provided by the hardware manufacturers and even differed from model to model. The first language to be consistent across models was Fortran but it was still only uniform for its manufacturer, IBM. A committee was formed to design the first truly universal, machine-independent programming language.</p>
<p>Arc de Triomphe , Champs-Elysées, Paris, 1960. Photo: Charles Weever Cushman (via University of Indiana)</p>
<p>In January 1960, 13 computer scientists met in Paris for an unprecedented meeting with the goal of developing such a language. There were 6 delegates sent from America and 7 delegates from Europe.</p>
<p>The meetings were exhausting, interminable, and exhilarating. One became aggravated when one’s good ideas were discarded along with the bad ones of others. Nevertheless, diligence persisted during the entire period. The chemistry of the 13 was excellent.
Alan Perlis</p>
<p>Algol</p>
<p>Here is a language so far ahead of its time that it was not only an improvement on its predecessors but also on nearly all its successors.
Tony Hoare
Hints on Programming Language Design – 1973</p>
<p>Algol
Algol W
In spite of that statement, Tony Hoare along with Niklaus Wirth went on to create a successor of ALGOL 60 called ALGOL W</p>
<p>Algol
Algol W
Pascal
which, in turn, led Wirth to go on to create Pascal which was initially published in 1970.</p>
<p>Algol
Algol W
Pascal
CPL
Independently CPL was created at the University of Cambridge as the &ldquo;Cambridge Programming Language&rdquo;</p>
<p>Algol
Algol W
Pascal
CPL
BCPL
it led to BCPL or Basic CPL, a much simpler language based on CPL.</p>
<p>Algol
Algol W
Pascal
CPL
BCPL
B
At Bell Labs in the US Ken Thompson and Dennis Ritchie created B, based mainly on BCPL</p>
<p>Algol
Algol W
Pascal
CPL
BCPL
B  C
and shortly after, it’s successor, C.</p>
<p>Algol
Algol W
Pascal
CPL
BCPL
B  C</p>
<p>Pascal
Modula
Oberon
The Pascal branch flourished in Europe, with many successors including Modula and Oberon.</p>
<p>C++
C#
C
Java
C proliferated in the US inspiring and enabling C++, C#, Java as well as JavaScript, Python, Perl, PHP and many many more languages.</p>
<p>Oberon
2007
Pascal
C
C++
C#
Java
Perl
Python
PHP
JS
Obj C
AWK
Modula
Ruby
Shell
By 2007 dozens of languages existed that can all trace their roots back to the common ancestor Algol</p>
<p>Why Another Language
SECTION TWO</p>
<p>Growing at Google Scale
SECTION 2.1
To understand the answer to this question we need to look at the environment from which Go was born.</p>
<p>At scale everything breaks no matter what you do and you have to deal reasonably cleanly with that and try to hide it from the people actually using your system.
Urs Hölzle
Google: &lsquo;At scale, everything breaks&rsquo;  –  2011
A bit more than 10 years after Google launched, it’s head of infrastructure Urs said&hellip;</p>
<p>In its first 10 years Google had experienced scale unlike the world had ever seen before. Growth of hundreds to 10s of thousands times.</p>
<p>In addition to machine scale, Google headcount also grew significantly from well under 1000 employees in 2000 to over 24k in 2010.</p>
<p>Urs Hölzle
Google: &lsquo;At scale, everything breaks&rsquo;  –  2011
Keeping things simple and yet scalable is actually the biggest challenge.
And through all this growth, Urs identified that …</p>
<p>Google’s Scale brought Complexity</p>
<ul>
<li>Massive codebases with many dozens of programmers</li>
<li>Very large build farms</li>
<li>45+ min builds</li>
</ul>
<p>Google was struggling with this challenge, especially within its engineering efforts internally.</p>
<p>Brian Kernighan
Software Tools –  1976
Controlling complexity is the essence of computer programming.
In 1976 BK wrote ….</p>
<p>So when faced with complexity a good computer scientist knows what to do.</p>
<p>During a 45 minute C++ build…
SECTION 2.2</p>
<p>Rob Pike
Paraphrase</p>
<p>Rob Pike’s words:
Back around September 2007, I was doing some minor but central work on an enormous Google C++ program, one you&rsquo;ve all interacted with, and my compilations were taking about 45 minutes on our huge distributed compile cluster. An announcement came around that there was going to be a talk presented by a couple of Google employees serving on the C++ standards committee. They were going to tell us what was coming in C++11.</p>
<p>In the span of an hour at that talk we heard about something like 35 new features that were being planned. …
At this point I asked myself a question:</p>
<p>Did the C++ committee really believe that was wrong with C++ was that it didn&rsquo;t have enough features? Surely&hellip;, it would be a greater achievement to simplify the language rather than to add to it.
Rob Pike
2007
Rob returned to his desk with his office mates. This really got them thinking about…</p>
<p>What should a modern, practical programming language look like?
By the time that 45 minute build was done they already had a whiteboard full of ideas.</p>
<p>Ken Thompson
Ken comes from US and C &amp; Unix</p>
<p>Robert Griesemer
Europe
Smalltalk &amp; Pascal</p>
<p>Studied under Niklaus Wirth</p>
<p>Algol
Algol W
Pascal
CPL
BCPL
B  C
Go is the first language that can claim heritage of both the European and US branches of language design. In a very real sense it has unified these two branches as well as a third branch we’ll talk about later.</p>
<p>We built from scratch, borrowing [from C] only minor things like operators and brace brackets and a few common keywords. And of course we also borrowed ideas from other languages we knew. &hellip;
Rob Pike
Less is Exponentially More –  2012
In speaking about Go’s inspiration, Rob Pike states…</p>
<p>Go’s Many Ancestors and Influences
Alef
Algol
APL
BCPL
B
C
C++
CLU
CSP
Java
Limbo
Modula
Newsqueak</p>
<p>Oberon
Occam
Pascal
Python
Simula
Smalltalk</p>
<p>I would claim that there has never been a set of language designers with broader or deeper language design expertise than these three. They had a
rich knowledge of what came before and they knew just what to cherry pick.</p>
<p>Go’s Design Principles
SECTION 2.3
Now I’d like to share with you the 4 design principles that guided the development of the Go language.</p>
<p>Evolution not
revolution
Most ideas come from
previous ideas
Principle 1. The idea is that most ideas are not new at all.</p>
<p>Evolution not
revolution
New languages should consolidate, not invent features</p>
<p>Waiting for
Good design
No is temporary,
Yes is forever
Principle 2. There are many instances of this throughout Go’s history. The general idea is that when you are designing a language there is no “undo”. If you say “No” today, you can always say “Yes” tomorrow, but if you say “Yes” today you are stuck with that forever…. Or for a long time.</p>
<p>Joshua Bloch
Joshua Bloch: A conversation about design –  2002
When in doubt,leave it out
Author of Effective Java</p>
<p>Consensus
driven design
As simple as possible,
but no simpler
Principle 3.</p>
<p>When the three of us got started, it was pure research. … We started off with the idea that all three of us had to be talked into every feature in the language, so there was no extraneous garbage put into the language for any reason.</p>
<p>Ken Thompson
Interview  –  2011
Ken brought this practice in from Bell Labs</p>
<p>There are two ways of constructing a software design.  One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies.
C.A.R. Hoare
The emperor’s old clothes  –  1981</p>
<p>Go Doesn’t have
Header files
Classes
Inheritance
Constructors
Pointer Arithmetic
Uninitialized values</p>
<p>Annotations
Templates
Exceptions
Globals
Void
&hellip;
By design Go’s approach is minimalist. With a goal of simplicity we tried to create a language with as small  a feature set as we could while keeping it productive and useful. A lot of features common in other languages were left out of Go including…</p>
<p>Rapid
Iteration
Expect &amp; enable
massive changes
The last principle is that of Rapid iteration. That when you are in the design phase of a language you will need to make frequent and sometimes dramatic changes. Go forward with that expectation and build your process around it.</p>
<p>Russ Cox
Ian Lance Taylor
Within a few months of that 45 minute whiteboard session the team had grown to 5 with the addition of Russ Cox and Ian Lance Taylor.</p>
<p>At this point all the Go source that existed in all of existence was in a single repo.
Whenever they made a change they would fix all 1000 or so Go files in existence and change them all at once and then commit them back to the repo.</p>
<p>The mechanism they used worked quite well, but they knew wouldn’t scale for long.
Russ would open all the Go files that existed in the world and made the changes with Rob, Ken &amp; Robert looking over his shoulder.</p>
<p>It was a lot of regexp search and replace and then nodding that it looked right.</p>
<p>Over a year of refining
Months of discussion, planning, prototyping, experimenting and whiteboarding
Added one feature at a time
Built two implementations (go, gccgo)</p>
<p>Nearly 5 years of refinement
2007
2009
2012
Started at Google as a 20% project
2 years later, Go is open sourced
After nearly 5 years of development, Go 1.0 is released and attention shifts to using Go
Open Source
Birth
1.0</p>
<p>We spent 5 years developing Go</p>
<p>SECTION 2.3</p>
<p>Concurrent</p>
<p>Simple</p>
<p>Powerful</p>
<p>Fast</p>
<p>Expressive</p>
<p>Readable</p>
<p>Type-safe</p>
<p>Compiled</p>
<p>Compiled
very quickly</p>
<p>Dynamic feeling</p>
<p>Go built for the world</p>
<p>Go was well received especially by the open source community who first embraced Go with notable projects including Docker, Kubernetes and Hugo.</p>
<p>JetBrains 2018 Developer Survey
<a href="https://www.jetbrains.com/research/devecosystem-2018/">https://www.jetbrains.com/research/devecosystem-2018/</a></p>
<p>Go’s adoption has been steady since the 1.0 release. Earlier this year Jetbrains awarded Go the title of most promising programming language.</p>
<p>Go Users
Worldwide 2018</p>
<p>1.5 – 2 Million</p>
<p>Gophers span the world</p>
<p>3 Features
of
SECTION THREE</p>
<p>I’d like to now turn our attention to three specific features of Go which I think you will find interesting to explore a bit deeper.</p>
<p>Object-OrientedProgramming
SECTION 3.1
The first is Go’s approach to Object Orientation.</p>
<p>C++/Java style OO is brittle
This may not be a popular opinion, but it was our experience that when you write programs as inheritance heavy subclass systems it forces you to make decisions early that are very hard to change later</p>
<p>If any part of a system depends on the internals of another part, then complexity increases as the square of the size of the system</p>
<p>Dan Ingalls
Object Oriented Programming — 1989</p>
<p>This should look familar to anyone who has programmed in an semi recent OO language. The relationships lines are everywhere.
<a href="http://www.ejb3.org/jar_file_reverse/jar_file_reverse.html">http://www.ejb3.org/jar_file_reverse/jar_file_reverse.html</a></p>
<p>Inheritance
And we see this exponential complexity in inheritance</p>
<p>Rich Hickey
Clojure for Java Programmers –  2012
It is my opinion that object oriented programming, as delivered by Java, etc., is not a good default way to structure your program.</p>
<p>OO existed long before C++/Java
However, before C++ and Java redefined Object Orientation there was…</p>
<p>Simulation Begin
Class FittingRoom; Begin
Ref (Head) door;
Boolean inUse;
Procedure request; Begin
If inUse Then Begin
Wait (door);
door.First.Out;
End;
inUse:= True;
End;
Procedure leave; Begin
inUse:= False;
Activate door.First;
End;
door:- New Head;
End;</p>
<p>Procedure report (message); Text message; Begin
OutFix (Time, 2, 0); OutText (&quot;: &quot; &amp; message); OutImage;
End;</p>
<p>Process Class Person (pname); Text pname; Begin
While True Do Begin
Hold (Normal (12, 4, u));
report  (pname &amp; &quot; is requesting the fitting room&rdquo;);
fittingroom1.request;
report (pname &amp; &quot; has entered the fitting room&rdquo;);
Hold (Normal (3, 1, u));
fittingroom1.leave;
report (pname &amp; &quot; has left the fitting room&rdquo;);
End;
End;</p>
<p>Integer u;
Ref (FittingRoom) fittingRoom1;</p>
<p>fittingRoom1:- New FittingRoom;
Activate New Person (&ldquo;Sam&rdquo;);
Activate New Person (&ldquo;Sally&rdquo;);
Activate New Person (&ldquo;Andy&rdquo;);
Hold (100);
End;</p>
<p>1965
Simula
Simula took Algol and added to it objects, classes, inheritance and subclasses</p>
<p>It is considered the first object-oriented programming language and was influential in
the development of Smalltalk and all following OO languages.</p>
<p>Code from – <a href="https://en.wikipedia.org/wiki/Simula">https://en.wikipedia.org/wiki/Simula</a></p>
<p>[Simula] change[d] from the procedural view, &hellip; they flipped it around to … the object-oriented one which is that within every type of object you have all the procedures that work on it.</p>
<p>Dan Ingalls
Object Oriented Programming — 1989
Dan Ingalls, the implementer of Small Talk said…</p>
<p>Object subclass: #Philosophers
instanceVariableNames: &lsquo;forks philosophers randy eating&rsquo;
classVariableNames: '&rsquo;
poolDictionaries: '&rsquo;
category: &lsquo;Examples-Processes&rsquo;!</p>
<p>!Philosophers class methodsFor: &lsquo;dining&rsquo;!</p>
<p>new
self shouldNotImplement
!</p>
<p>new: quantity
^super new initialize: quantity
! !</p>
<p>!Philosophers methodsFor: &lsquo;dining&rsquo;!</p>
<p>dine
self dine: 15
!</p>
<p>dine: seconds
(Delay forSeconds: seconds) wait.
philosophers do: [ :each | each terminate ].
self initialize: self size
!</p>
<p>leftFork: n
^forks at: n
!</p>
<p>rightFork: n
^n = self size
ifTrue: [ forks at: 1 ]
ifFalse: [ forks at: n + 1 ]
!</p>
<p>initialize: n
eating := Semaphore new.
n - 1 timesRepeat: [ eating signal ].</p>
<pre><code>randy := Random new.
forks := (1 to: n) collect: [ :each | Semaphore forMutualExclusion ].
</code></pre>
<p>Smalltalk
1980
Next came Smalltalk where everything is an object and objects are only communicated with via the sending of messages</p>
<p>Code from : <a href="https://raw.githubusercontent.com/gnu-smalltalk/smalltalk/master/examples/Dinner.st">https://raw.githubusercontent.com/gnu-smalltalk/smalltalk/master/examples/Dinner.st</a></p>
<p>Alan Kay
A to Z of programming languages: Smalltalk-80 –  2010
I did make up this term [object oriented] and it was a bad choice because it under-emphasized the more important idea of message sending.</p>
<p>Smalltalk OO is about message sending
1980
An oversimplification, but a not inaccurate one</p>
<p>Go‘s OO
is patterned
after Smalltalk</p>
<p>Go isn’t pure OO like smalltalk, but the fundamentals are there.</p>
<p>Go’s OO
Methods
&amp;
Interfaces
There are only two mechanisms in Go that provide the object oriented functionality.</p>
<p>Methods
(on any type)
It took them awhile to realize the only way to do this was to focus only on methods (and not structure) and to permit methods being defined on any type.</p>
<p>Go Methods
type Phone []int</p>
<p>func (p Phone) String() string {
text := &quot;&rdquo;
for _, digit := range p {
text += string(&lsquo;0&rsquo; + digit)
}
return text
}</p>
<p>Go Methods
type Phone []int</p>
<p>func (p Phone) String() string {
text := &quot;&rdquo;
for _, digit := range p {
text += string(&lsquo;0&rsquo; + digit)
}
return text
}</p>
<p>Interfaces
Interface types are the mechanism to support an object-oriented programming style.</p>
<p>Interfaces give you a form of dynamic dispatch</p>
<p>Go Interfaces
type Stringer interface {
String() string
}</p>
<p>Go Interfaces
type Stringer interface {
String() string
}</p>
<p>Go Interfaces
type Stringer interface {
String() string
}</p>
<p>func Print(s Stringer) {
fmt.Println(s.String())
}</p>
<p>Go Interfaces
type Stringer interface {
String() string
}</p>
<p>func Print(s Stringer) {
fmt.Println(s.String())
}</p>
<p>Go Methods
type Phone []int</p>
<p>func (p Phone) String() string {
text := &quot;&rdquo;
for _, digit := range p {
text += string(&lsquo;0&rsquo; + digit)
}
return text
}</p>
<p>Interfaces are implicit, not explicit.
Implementation is entirely independent from each other.</p>
<p>Go Methods &amp; Interfaces</p>
<p>func main() {
p := Phone{8,0,0,5,5,5,1,3,1,3}
Print(p)
}</p>
<p>When you try to try to break a complex problem down you want to try to break it down into as few parts as you can and you want them to be as independent as they can be.</p>
<p>Dan Ingalls
Object Oriented Programming — 1989
Go’s approach of interfaces and methods is as independent as possible. Any type can satisfy any interface as long as the right methods are added. An interface can be defined before or after the types that satisfy the interface. It just works and it works well.</p>
<p>Go’s OO
Methods provide message sending mechanism on any type</p>
<p>Interfaces provide reusability through dynamic dispatch polymorphism</p>
<p>Go is OO in a very real sense as defined by smalltalk even though it doesn’t include classes, objects or inheritance.</p>
<p>Concurrency
SECTION 3.2</p>
<p>Rob Pike
Concurrency is not Parallelism  –  2013
Concurrency is not parallelism. …
Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
Parallelism means running code on multiple CPUs at once.</p>
<p>Concurrency is about writing clear programs, so that it’s easy to explain how the program does many things at once.</p>
<p>If you have only one processor, your program can still be concurrent to make it easy to write, but it cannot run in parallel.
But then if you do have multiple processors, there’s an obvious way to parallelize a concurrent program.</p>
<p>Joe ArmstrongProgramming Erlang —  2007</p>
<p>The world is parallel. If we want to write programs that behave as other objects in the real world, then these programs will have a concurrent structure.
Joe Armstrong, the creator of Erlang says…</p>
<p>And even though we have shifted topics to concurrency, Joe is making a case here that a truly object oriented language must be concurrent.</p>
<p>Doug McIlroy
<a href="http://facesofopensource.com/doug-mcilroy/">http://facesofopensource.com/doug-mcilroy/</a></p>
<p>Our Concurrency story begins with Doug McIlroy</p>
<p>Unix Pipes
1964
Who back in 1964 came up with the idea that became Unix pipes.</p>
<p>1964
We should have some ways of coupling programs like garden hose&ndash;screw in another segment when it becomes necessary to massage data in another way. This is the way of IO also.</p>
<p>Paraphrase story.</p>
<p>And over a period from 1970 to 1972, I&rsquo;d from time to time say, &ldquo;How about making something like this?&quot;, and I&rsquo;d put up another proposal, another proposal, another proposal. And one day I came up with a syntax for the shell that went along with the piping, and Ken said, &ldquo;I&rsquo;m going to do it!&rdquo; He was tired of hearing all this stuff… [and] he said, &ldquo;I&rsquo;m going to do it.&rdquo; He didn&rsquo;t do exactly what I had proposed for the pipe system call; he invented a slightly better one that finally got changed once more to what we have today. He put pipes into Unix [and he did it]&hellip; all in one night.</p>
<p>Quoting McIlroy:
There&rsquo;s a paper that&rsquo;s hanging on Brian&rsquo;s wall still, [which] he dredged out somewhere, where I talked about screwing together streams like garden hoses. So this idea had been banging around in my head for a long time.</p>
<p>At the same time that Thompson and Ritchie were on their blackboard, sketching out a file system, I was sketching out how to do data processing on this blackboard by connecting together cascades of processes and looking for a kind of prefix notation language for connecting processes together, and failing because it&rsquo;s very easy to say &ldquo;cat into grep into &hellip;&quot;, or &ldquo;who into cat into grep&rdquo;, and so on; it&rsquo;s very easy to say that, and it was clear from the start that that was something you&rsquo;d like to say. But there are all these side parameters that these commands have; they don&rsquo;t just have input and output arguments, but they have the options, and syntactically it was not clear how to stick the options into this chain of things written in prefix notation, cat of grep of who [i.e. cat(grep(who &hellip;))]. Syntactic blinders: didn&rsquo;t see how to do it. So I had these very pretty programs written on the blackboard in a language that wasn&rsquo;t strong enough to cope with reality. So we didn&rsquo;t actually do it.</p>
<p>Tony Hoare
By 1978, there were many proposed methods in use for communication and synchronization in the context of programming multiprocessors. Shared memory was the most common communication mechanism.</p>
<p>Tony Hoare published a paper which changed everything. It was decades ahead of its time. He called his paper, communicating sequential processes.</p>
<p>CSP
1978
Or as it’s better know, CSP.</p>
<p>CSP
1978
Processes: unit of execution
Sequential: each runs as an ordinary single-thread program
Communicating: how processes coordinate
No sharing of memory
No threads, no mutexes
Hoare’s paper proposed a language with processes each running sequentially (or as an ordinary single threaded program) communicating with each other over unbuffered channels.</p>
<p>Hoare&rsquo;s communicating processes are more general than typical Unix shell pipelines, since they can be connected in arbitrary patterns.</p>
<p>Prime Sieve
200 BC
Hoare got the idea to include this from Doug McIlroy and included it in his paper.</p>
<p>In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit.
Doug McIlroy came up with the concurrent version of the Prime Sieve.</p>
<p>2
3
4
5
6
7
8
9
10
11
12
&hellip;</p>
<p>2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;</p>
<p>2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;</p>
<p>2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;</p>
<p>2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
2
3
4
5
6
7
8
9
10
11
12
&hellip;
&hellip;</p>
<p>CSP (from Hoare’s 1978 paper)
1978
[SIEVE(i:1..100)::
p,mp:integer;
SIEVE(i - 1)?p;
print!p;
mp := p; comment mp is a multiple of p;
*[m:integer; SIEVE(i - 1)?m →
<em>[m &gt; mp → mp := mp + p];
[m = mp → skip
||m &lt; mp → SIEVE(i + 1)!m
]   ]
||SIEVE(0)::print!2; n:integer; n := 3;
<em>[n &lt; 10000 → SIEVE(1)!n; n := n + 2]
||SIEVE(101)::</em>[n:integer;SIEVE(100)?n → print!n]
||print::</em>[(i:0..101) n:integer; SIEVE(i)?n → &hellip;]
]</p>
<p><a href="https://rosettacode.org/wiki/Sieve_of_Eratosthenes">https://rosettacode.org/wiki/Sieve_of_Eratosthenes</a></p>
<p>CSP
Erlang
Go
Occam
Three branches of languages emerged from the CSP paper.</p>
<p>Occam in 1983 was close to CSP paper (advised by Hoare)
Erlang in late 80s focused on functional side of CSP and used mailboxes to communicate between processes</p>
<p>Rob Pike
Go’s story begins with Rob pike… but not this Rob Pike&hellip;</p>
<p>Rob Pike
This much younger one.. back in 1989</p>
<p>Newsqueak
1989
Rob worked on a successor to an even earlier toy language called Squeak while at Bell Labs</p>
<p>Newsqueak
1989
Research language
Make concurrency in Squeak practical
Syntactically like C
Like CSP, used channels as rendezvous points for processes.</p>
<p>Rob Pike
Newsqueak (1989) looked syntactically like C but was applicative and concurrent.</p>
<p>Idea: a research language to make the concurrency ideas of Squeak practical.</p>
<p>Newsqueak addresses the same problems but in a broader context: Squeak was for designing devices
such as menus and scroll bars; Newsqueak is for writing entire applications, and in particular a window system.</p>
<p>Newsqueak’s communication mechanisms are as in CSP, with channels acting as rendezvous
points for processes.</p>
<p>Fun for after the talk: <a href="https://swtch.com/~rsc/thread/squint.pdf">https://swtch.com/~rsc/thread/squint.pdf</a>.</p>
<p>Newsqueak — Prime Sieve pt. 1
1988
counter := prog(end: int, c: chan of int) {
i: int;
for(i = 2; i&lt;end; i++)
c&lt;-=i;
};</p>
<p>filter := prog(prime: int, listen, send: chan of int) {
i: int;
for(;;)
if((i=&lt;-listen)%prime)
send&lt;-=i;
};</p>
<p>Newsqueak — Prime Sieve pt. 2
1988
sieve := prog(c: chan of int) {
for(;;) {
prime := &lt;-c;
print(prime, &quot; &ldquo;);
newc := mk(chan of int);
begin filter(prime, c, newc);
c = newc;
}
};</p>
<p>count := mk(chan of int);</p>
<p>begin counter(10000, count);
sieve(count);
Unlike in CSP and Squeak,  Newsqueak treats communications channels as first-class objects:
channels can be stored in variables, passed as arguments to functions, and sent across channels.</p>
<p>Also &lt;-c (receive) is an expression introduce here for the first time (it would later surface in Go)</p>
<p>Alef, Limbo
1990s</p>
<p>Alef &amp; Limbo
1990s
Used for writing real systems software
Built on concurrency ideas in Newsqueak
Alef wasn’t GC’ed and it was painful
Limbo was GC’ed and it was wonderful</p>
<p>both languages that Rob used for writing real systems software
Alef was done for Plan 9 (Bell labs successor to UNIX)
Limbo was done for Inferno, successor to Plan 9
convinced Rob and the others at Bell Labs that CSP was a great way to write concurrent programs like network servers</p>
<p>.
2008</p>
<p>Go
2008
Goroutines
&amp;
Channels
Go has</p>
<p>Goroutines
<a href="https://play.golang.org/p/IXkwo_-ruTC">https://play.golang.org/p/IXkwo_-ruTC</a>
func main() {
go printer(99)
time.Sleep(1 * time.Second)
}</p>
<p>func printer(n int) {
for i := 0; i &lt; n; i++ {
fmt.Println(i)
time.Sleep(5 * time.Millisecond)
}
}
A Goroutine is a function that executes independently, launched by a go statement.</p>
<p>It has its own call stack, which grows and shrinks as required.
It&rsquo;s very cheap. It&rsquo;s practical to have thousands, even hundreds of thousands of goroutines.</p>
<p>It isn’t a thread. The Go runtime multiplexes goroutines onto threads as needed.
There might be only one thread in a program with thousands of goroutines.</p>
<p>Ryan Dahl
Interview with Ryan Dahl, Creator of Node.js –  2017
I like the programming model of Go. Using goroutines is so easy and fun&hellip; if you’re building a server, I can’t imagine using anything other than Go.
Goroutines are what make concurrency in Go simple.</p>
<p>Channels
// Declaring and initializing
c := make(chan int)</p>
<pre><code>// Sending a value on a channel
c &lt;- 1

// Receiving a value from a channel
x = &lt;-c


// Data flows the way the arrow points.
</code></pre>
<p>Next is channels which are going to look quite similar to the last few languages we just discussed.</p>
<p>Go — Prime Sieve Pt. 1
2009
func Generate(ch chan&lt;- int) {
for i := 2; ; i++ {
ch &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;ch&rsquo;.
}
}
func Filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
for i := range src {  // Loop over values received
if i%prime != 0 {
dst &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;dst&rsquo;.
}
}
}</p>
<p>Go — Prime Sieve Pt. 1
2009
func Generate(ch chan&lt;- int) {
for i := 2; ; i++ {
ch &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;ch&rsquo;.
}
}
func Filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
for i := range src {  // Loop over values received
if i%prime != 0 {
dst &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;dst&rsquo;.
}
}
}</p>
<p>Go — Prime Sieve Pt. 1
2009
func Generate(ch chan&lt;- int) {
for i := 2; ; i++ {
ch &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;ch&rsquo;.
}
}
func Filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
for i := range src {  // Loop over values received
if i%prime != 0 {
dst &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;dst&rsquo;.
}
}
}</p>
<p>Go — Prime Sieve Pt. 1
2009
func Generate(ch chan&lt;- int) {
for i := 2; ; i++ {
ch &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;ch&rsquo;.
}
}
func Filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
for i := range src {  // Loop over values received
if i%prime != 0 {
dst &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;dst&rsquo;.
}
}
}</p>
<p>Go — Prime Sieve Pt. 1
2009
func Generate(ch chan&lt;- int) {
for i := 2; ; i++ {
ch &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;ch&rsquo;.
}
}
func Filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
for i := range src {  // Loop over values received
if i%prime != 0 {
dst &lt;- i  // Send &lsquo;i&rsquo; to channel &lsquo;dst&rsquo;.
}
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>// 2</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009  – <a href="https://play.golang.org/p/s88CRWdCrOz">https://play.golang.org/p/s88CRWdCrOz</a>
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for i := 0; i &lt; 100; i++ { // Find 100 primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>Go — Prime Sieve Pt. 2
2009
func main() {
src := make(chan int) // Create a new channel.
go Generate(src)      // Launch Generate goroutine.
for { // Find all primes
prime := &lt;-src
println(prime)
dst := make(chan int)
go Filter(src, dst, prime)
src = dst
}
}</p>
<p>go fmt
&amp;
go fix
SECTION 3.3</p>
<p>go fmt</p>
<p>// Ext returns the file name extension used by path.
func Ext(path string) string {
for i:=   len( path ) - 1;
i &gt;= 0   &amp;&amp;   path[i] != &lsquo;/';
i&ndash; {
if  path[ i] == &lsquo;.&rsquo; {
return    path[i: ]
}
}
return &quot;&rdquo;
}
Unformatted Go Code</p>
<p>// Ext returns the file name extension used by path.
func Ext(path string) string {
for i := len(path) - 1; i &gt;= 0 &amp;&amp; path[i] != &lsquo;/'; i&ndash; {
if path[i] == &lsquo;.&rsquo; {
return path[i:]
}
}
return &quot;&rdquo;
}
Formatted Go Code</p>
<p>go fmt
Parses Go source into syntax trees
Prints syntax trees back into source code
Uses the std lib support for these actions
Ended all style debates in Go before they even happened</p>
<p>// Read implements the io.Reader interface.
func (r *Reader) Read(b []byte) (n int, err error) {
if r.i &gt;= int64(len(r.s)) {
return 0, io.EOF
}
r.prevRune = -1
n = copy(b, r.s[r.i:])
r.i += int64(n)
return
}</p>
<p>No fingerprints left on code
It doesn’t look like generated code, but in reality all Go is machine generated code
An unforseen and wonderful artifact of GoFmt is that there are no fingerprints on Go code. Looking through all of the source code written on our team it’s impossible to tell who’s code is whose. It’s also impossible to tell which code is generated code vs code written by hand.. And that’s because all of it is generated but in a way that looks and feels natural.</p>
<p>Not what you’d think as a language feature</p>
<p>Planned from
the beginning</p>
<p>Last thing we did before open sourcing Go</p>
<p>It turned out to be one of the best things we did</p>
<p>Now other languages are doing it
(C++, Rust, etc)</p>
<p>Russ Cox
Mailing List November 2009
Once you have gofmt, it becomes very easy to insert mechanical processing between parsing and printing.  So we have all the hard parts of a program
manipulation tool just sitting waiting to be used.</p>
<p>Which takes us to &hellip;</p>
<p>go fix</p>
<p>go fix
Rewrite programs that use old APIs to use newer ones
Much more intelligent than regex rewriting
Allows API changes to be shipped along with code changes</p>
<p>os.Open(a, os.O_RDONLY, 0)
os.Open(a, os.O_RDONLY, 0666)
os.Open(a, os.O_RDWR, 0)
os.Open(a, os.O_CREAT, 0666)
os.Open(a, os.O_CREAT|os.O_TRUNC, 0664)
os.Open(a, os.O_CREATE, 0666)
os.Open(a, os.O_CREATE|os.O_TRUNC, 0664)
os.Open(a, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
os.Open(a, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
os.Open(a, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0666)
os.Open(a, os.O_SURPRISE|os.O_CREATE, 0666)
_ = os.O_CREAT</p>
<p>Originally there was just a multi-arg os.Open:
Originally there was just a multi-arg os.Open which exposed the UNIX api to our users.</p>
<p>Go Fix let us take this bad API and convert it to one that is dramatically better.</p>
<pre><code>os.Open(a)
os.Open(a)
os.OpenFile(a, os.O_RDWR, 0)
os.Create(a)
os.Create(a)
os.Create(a)
os.Create(a)
os.Create(a)
os.OpenFile(a, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
os.OpenFile(a, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0666)
os.OpenFile(a, os.O_SURPRISE|os.O_CREATE, 0666)
_ = os.O_CREATE
</code></pre>
<p>Go Fix let us take an API and convert it to a better one
No regEx could have made these changes. They required a deep knowledge of the internal structure. It was easy with Go Fix.</p>
<p>Later we used it to make more significant changes to reflect
Too many words</p>
<p>Russ Cox
Introducing Gofix  –  2011
The recent reflect changes would have been unpalatable without automated conversion, and the reflect API badly needed to be redone. Gofix gives us the ability to fix mistakes or completely rethink package APIs without worrying about the cost of converting existing code.</p>
<p>We’ve only scratched the surface
Go upgrades
Look for patterns that are problematic and fix it.
Lots more ways for computer to help you write and maintain your programs.</p>
<p>The Future
of Go
SECTION FOUR</p>
<p>2</p>
<p>Nearly 5 years of refinement
2007
2009
2012
Started at Google as a 20% project
2 years later, Go is open sourced
After nearly 5 years of development, Go 1.0 is released and attention shifts to using Go
Open Source
Birth
1.0</p>
<p>We spent 5 years developing Go</p>
<p>2012
After nearly 5 years of development, Go 1.0 is released and attention shifts to using Go
1.0
5 years of gaining experience &amp; refining the implementation
2017
After nearly 5 years of development using Go,  attention shifts to making language changes again
Go 2 begins</p>
<p>We spent the next 5 years using and refining Go’s implementation. We have now shifted our attention to making language changes again.</p>
<p>A series of releases starting with Go 1.11 in August 2018</p>
<p>Might just be Go 1.x for increasing x.</p>
<p>Go 2 is a process with a series of releases starting with Go 1.11
2
We call this process Go 2. It is a series of releases starting with Go 1.11 in August. There may not be a Go 2.0 release as a result of this process. We have not yet committed to any breaking changes.</p>
<p>Go started as a collaboration among 3 people</p>
<p>Go continues to be designed using a collaborative approach</p>
<p><a href="https://github.com/golang/proposal">https://github.com/golang/proposal</a>
Our proposal process permits anyone to help shape the future of Go. All changes to the language go through this same process. If you want to help define the future of Go please join us.</p>
<p>Dependency Management
SECTION 4.3</p>
<p>I want to talk about one feature that is coming in our next release.
It’s the first “Go 2 feature” and one that our users have been asking for for a long time. Dependency Management.</p>
<p>go get(for Go 1)
For Go’s 1.0 release we included dependency management in the form of the go get tool.</p>
<p>Example of go get</p>
<p>Import package using canonical address</p>
<p>go get <!-- raw HTML omitted --></p>
<p>import &ldquo;github.com/spf13/cobra&rdquo;
$ go get github.com/spf13/cobra
Here’s how you use it.</p>
<p>go get got a lot right
No configuration outside source code(just import statement)
Very easy to use
URL-like import paths
Eliminated central hub
Worked very well in practice
No diamond dependency problems</p>
<p>go get got some things wrong
Only update operation was“upgrade everything to latest code”
No explicit concept of versions at all
No good way to make abackwards-incompatible change
Unreproducible builds</p>
<p>go get(for Go 2)
For Go 2 we are reimagining go get</p>
<p>Semantic import versioning
There’s a lot that goes into dependency management, I’m just going to focus on one change.</p>
<p>Russ Cox
“Import compatibility rule” — 2018
If an old package and a new package have the same import path, the new package must be backwards compatible with the old package.
With Go 1.0 we issued a compatability guarantee and encouraged our package developers to give similar expectations of compatibility.
We later canonized this in what is now called the import compatibility rule:
“If an old package and a new package have the same import path, the new package must be backwards compatible with the old package.”</p>
<p>By extension this means that if a new package is not backwards compatible than it must have a different import path</p>
<p>Semantically versioned imports</p>
<p>Import package using canonical address</p>
<p>go build</p>
<p>import &ldquo;github.com/spf13/cobra/v2&rdquo;
$ go build</p>
<p>Other big parts
Modules (!= packages, repos)
Minimum version selection
Reproducible, verifiable, verified builds
Integrated into standard go
Same user workflow</p>
<p>Go 1.11</p>
<p>(August 2018)</p>
<p>Go 1.11
Dependency Management (experimental)
Improved debugging and latency diagnosis
Improved GC automatic tuning
Experimental support for WebAssembly (WASM).</p>
<p>Generics
SECTION 4.4</p>
<p>Discussed from the earliest of days</p>
<ul>
<li>Ian was very interested, floated proposals about once a year, all had serious problems (proposals now public).</li>
<li>Still thinking about it.</li>
</ul>
<p>Joshua Bloch
Joshua Bloch: A conversation about design –  2002
When in doubt,leave it out</p>
<ul>
<li>Friends who worked on Java Generics told us to be very very careful. Told us to not do it.</li>
<li>So we didn’t.</li>
</ul>
<p>Waiting for
Good design
No is temporary,
Yes is forever
We still adhere to our 4 design principles. We’re going to keep working on it until we have the right design</p>
<p>The Legacy
of Go
SECTION FIVE</p>
<p>Isaac Newton
1675
If I have seen further, it is by standing on the shoulders of Giants</p>
<p>John of Salisbury
Metalogicon — 1159
Bernard of Chartres used to compare us to dwarfs perched on the shoulders of giants. He pointed out that we see more and farther than our predecessors, not because we have keener vision or greater height, but because we are lifted up and borne aloft on their gigantic stature.
John of Salisbury. In 1159, John wrote in his Metalogicon</p>
<p>In a very real sense, Go is built upon the shoulders of giants</p>
<p>David McCullough
2012
History is who we are and why we are the way we are.
We are each all shaped by the history of what came before.</p>
<p>Go’s Many Ancestors and Influences
Alef
Algol
APL
BCPL
B
C
C++
CLU
CSP
Java
Limbo
Modula
Newsqueak</p>
<p>Oberon
Occam
Pascal
Python
Simula
Smalltalk</p>
<p>It’s impossible to look at Go without seeing reflections of it’s many ancestors.</p>
<p>We are hugely in debt to the many languages and individuals who laid the foundation for us to build upon.</p>
<p>We hope that Go has raised the shoulders a bit more and will be a springboard for the next generation of computer scientists.</p>
<p>Thank You
Curry On – Amsterdam – July 17 2018
Steve Francia
Google
@spf13</p>
        </article>
  </div>
</section>



<aside id="meta">

    <div>
        <section id="datecount">
          <h4 id="date"> Tue Jul 17, 2018 </h4>
          <h5 id="wc"> 6800 Words </h5>
          <h5 id="readtime"> Read in about 32 Min </h5>
        </section>
        <ul id="categories">
          
            <li><a href="http://localhost:888//topics/Development">Development</a> </li>
          
            <li><a href="http://localhost:888//topics/golang">golang</a> </li>
          
        </ul>
        <ul id="tags">
          
            <li> <a href="http://localhost:888//tags/go">go</a> </li>
          
            <li> <a href="http://localhost:888//tags/development">development</a> </li>
          
            <li> <a href="http://localhost:888//tags/history">history</a> </li>
          
            <li> <a href="http://localhost:888//tags/language-design">language design</a> </li>
          
        </ul>
    </div>

    <div>
        <section id="prev">
            &nbsp;<a class="previous" href="http://localhost:888/presentation/go-a-global-phenomenon/"><i class="icon-arrow-left"></i> 演讲：Go, a global phenomenon (英语演讲)</a><br>
        </section><section id="next">
            &nbsp;<a class="next" href="http://localhost:888/presentation/product-management-for-everyone/">Product Management for Everyone <i class="icon-arrow-right"></i></a>
        </section>
    </div>

    <div> <section id="author"> <h4>About the Author:</h4> 

            <p>
            Steve Francia is an American Software Engineer, Speaker & Author
            based in NYC. He has the unique distinction of 
            leadership roles in five of the largest open source projects. 
            </p>

            <p>
            He currently works at <a href="http://google.com">Google</a> on the leadership team 
            of <a href="http://golang.org">the Go
                language</a> where  he is responsible for the strategy and product of
            the Go project and it's over 1M users.
            </p>

            <p>
            He previously held executive roles at <a href="http://docker.com">Docker</a>, <a
            href="http://mongodb.com">MongoDB</a> where he
            led engineering, product and open source. 
            He formerly was a director of the <a href="http://drupal.org">Drupal Association</a>.
            </p>
            
            <p> 
            He is the creator of some of the world's most popular open source applications and libraries including <a href="http://gohugo.io">Hugo</a>, <a
                href="http://github.com/spf13/cobra">Cobra</a>, <a
                href="http://github.com/spf13/viper">Viper</a>, <a
            href="http://vim.spf13.com">spf13-vim</a> and many <a
            href="http://github.com/spf13">more</a>.
            </p>
            
            <p>
            Above all of these accomplishments, he is a father of 4. 
            Outside of technology Steve likes travel, skateboarding, punk rock, and dystopian films.
            </p>

        </section> </div>

</aside>

<meta itemprop="wordCount" content="6716">
<meta itemprop="datePublished" content="2018-07-17">
<meta itemprop="url" content="http://localhost:888/presentation/on-the-shoulders-of-giants/">



<footer>
  <div>
    <p>
    &copy; 2013-19 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Steve Francia.</span></span>
    <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons Attribution">Some rights reserved</a>;
    please attribute properly and link back. <br>
    Powered by <a href="http://gohugo.io">Hugo</a>.
    </p>
  </div>
</footer>
<script type="text/javascript">
(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)
</script>

</body>
</html>

